<!DOCTYPE html5>

<html>
	<head>
		<script src="https://d3js.org/d3.v5.min.js"></script>
		<style>
			#boundary {
				stroke: gray;
				stroke-width: 3;
			}

			.car {
				stroke: black;
				stroke-width: 3;
			}

			.center {  
				position: fixed;
				top: 50%;
				left: 50%;
				/* bring your own prefixes */
				transform: translate(-50%, -50%);
			}
		</style>
	</head>
	<body>
		<div class="center">
			<svg width="800", height="800">
				<rect id="boundary", width="600", height="600", x="100", y="100", fill="#FFFFFF"></rect>
				<g id="cars">
				</g>
			</svg>
		</div>
		<script>
			var svg = d3.select("svg").select("g");

			/*
			 * Raw level representation
			 * .: Empty, X: Red car, Other alphabets: Other cars
			 */

			var rawLevelStrings = [
				"AA...O" +
				"P..Q.O" +
				"PXXQ.O" +
				"P..Q.." +
				"B...CC" +
				"B.RRR." ,
				"A..OOO" +
				"A..B.P" +
				"XX.BCP" +
				"QQQ.CP" +
				"..D.EE" +
				"FFDGG." ,
				"......" +
				"......" +
				".XXO.." +
				".AAO.P" +
				".B.O.P" +
				".BCC.P" ,
				"O..P.." +
				"O..P.." +
				"OXXP.." +
				"..AQQQ" +
				"..A..B" +
				"..RRRB" , 
				"AA.O.B" +
		 		"P..OQB" +
				"PXXOQG" +
				"PRRRQG" +
				"D...EE" +
				"D...FF" ,
				"AA.B.." +
				"CC.BOP" +
				".XXQOP" +
				"DDEQOP" +
				"F.EQ.." +
				"F..RRR" ,
				".ABBCD" +
				".A.ECD" +
				".XXE.F" +
				"..II.F" +
				"...H.." +
				"...H.." ,
				"...AAO" +
				"..BBCO" +
				"XXDECO" +
				"FFDEGG" +
				"HHIPPP" +
				"KKIQQQ" ,
				".ABBCC" +
				".A.DEE" +
				"XX.DOF" +
				"PQQQOF" +
				"P.G.OH" +
				"P.G..H" ,
				"AAB.CC" +
				"DDB..O" +
				"PXX..O" +
				"PQQQ.O" +
				"P..EFF" +
				"GG.EHH"
			];

			var colorMap = {
				'A': "#7BBE3F",
				'B': "#F9A22D",
				'C': "#9EC0D2",
				'D': "#FFC0BD",
				'E': "#8941B7",
				'F': "#00824A",
				'G': "#474747",
				'H': "#F0E9C9",
				'I': "#EDEDED",
				'J': "#784B00",
				'K': "#003D20",
				'O': "#FFF200",
				'P': "#F5D3FD",
				'Q': "#3B39AA",
				'R': "#26A96A",
				'X': "#FF0000"
			};

			var cellSize = 100;
			var startX = 100, startY = 100;
			function i_to_x(i) { return startX + cellSize * i; }
			function j_to_y(j) { return startY + cellSize * j; }

			var CarType = Object.freeze({
				HORIZONTAL: "HORIZONTAL",
				VERTICAL: "VERTICAL"
			});
			var carData;
			var occupied; // Stores occupied cells

			function loadLevel(rawLevelString) {
				var rawLevel = [];
				for (var i = 0; i < 36; i += 6)
					rawLevel[i / 6] = rawLevelString.slice(i, i + 6).toUpperCase().split("");
				for (var i = 0; i < 6; i++)
					for (var j = 0; j < i; j++) {
						var tmp = rawLevel[i][j];
						rawLevel[i][j] = rawLevel[j][i];
						rawLevel[j][i] = tmp;
					}

				function extractCar(i, j) {
					var carName = rawLevel[i][j];
					
					if (carName == '.') {
						throw new Error("Tried to extract a car on an empty place");
						return;
					}
					
					if (carName in carData) {
						throw new Error("Multiple cars of same alphabet detected");
						return;
					}

					if (!(carName in colorMap)) {
						throw new Error("Car with undefined color detected");
						return;
					}

					if (i + 1 < 6 && rawLevel[i + 1][j] == carName) {
						// The car is horizontal
						var len = 0;
						// Read off the car and clear up the charaters
						while (i + len < 6 && rawLevel[i + len][j] == carName) {
							rawLevel[i + len][j] = '.';
							occupied[i + len][j] = true;
							len++;
						}

						carData[carName] = {
							name: carName,
							i: i, 
							j: j, 
							length: len, 
							type: CarType.HORIZONTAL,
							x: i_to_x(i),
							y: j_to_y(j)
						};
					} else if (j + 1 < 6 && rawLevel[i][j + 1] == carName) {
						// The car is vertical
						var len = 0;
						// Read off the car and clean up the characters
						while (j + len < 6 && rawLevel[i][j + len] == carName) {
							rawLevel[i][j + len] = '.';
							occupied[i][j + len] = true;
							len++;
						}

						carData[carName] = {
							name: carName,
							i: i, 
							j: j, 
							length: len, 
							type: CarType.VERTICAL,
							x: i_to_x(i),
							y: j_to_y(j)
						};
					} else {
						// The car is neither horizontal or vertical (of size 1)
						throw new SyntaxError("A car of size 1 by 1 detected");
						return;
					}
				}

				carData = [];
				occupied = (new Array(6)).fill([]).map(function(){
					return (new Array(6)).fill(false);
				});

				// Extract car data from input
				for (var i = 0; i < 6; i++)
					for (var j = 0; j < 6; j++)
						if (rawLevel[i][j] != '.')
							extractCar(i, j);	
				if (!('X' in carData))
					throw new SyntaxError("There is no car of name X");
				carData['X'].escaped = false;
				if (carData['X'].j != 2)
					throw new SyntaxError("The car X is not positioned at j == 2");

				// Attach and render car data
				var cars = svg.selectAll("rect")
					.data(Object.values(carData))
					.enter().append("rect")
					.classed("car", true)
					.attr("width", function (d) {
						if (d.type == CarType.HORIZONTAL)
							return cellSize * d.length;
						else
							return cellSize;
					})
					.attr("height", function (d) {
						if (d.type == CarType.VERTICAL)
							return cellSize * d.length;
						else
							return cellSize;
					})
					.attr("x", function (d) { return d.x; })
					.attr("y", function (d) { return d.y; })
					.attr("fill", function (d) { return colorMap[d.name]; });

				cars.call(d3.drag()
					.on("start", onDragStart)
					.on("drag", onDrag)
					.on("end", onDragEnd));
			}

			// Attach events
			function onDragStart(d) {
				// If the main car escaped, then do nothing
				if (d.name == 'X' && d.escaped)
					return;

				d3.select(this).raise().classed("active", true);

				if (d.type == CarType.HORIZONTAL) {
					d.min_i = d.i;
					d.max_i = d.i + d.length - 1;
				} else if (d.type == CarType.VERTICAL) {
					d.min_j = d.j;
					d.max_j = d.j + d.length - 1;
				}
			}

			/*
			 * Function that updates the car
			 * 'car': Horizontal car HTML element
			 * d: Data attached to car
			 * x: New (suggested) position of the car
			 * cilp: true if the car has to be clipped, false if not
			 * 
			 * Updates the position, metadata
			 */
			function updateHorizontalCar(car, d, x, clip) {
				// Calculate the new range of indicies the car will take
				var min_i = d.min_i, max_i = d.max_i;

				var new_min_i = Math.floor((x - startX) / cellSize);
				var new_max_i = Math.ceil((x - startX) / cellSize + d.length) - 1;				

				// true if and only if the car is main and escapes the screen
				var escape = false;

				// If new range is out of screen, clip to screen.
				if (new_min_i < 0) {
					new_min_i = 0;
					new_max_i = d.length - 1;
				}
				if (new_max_i >= 6) {
					if (d.name == 'X') { // If the car is main, clip to screen over right
						new_min_i = 6 - d.length + 1;
						new_max_i = 6;
					} else {
						new_min_i = 6 - d.length;
						new_max_i = 6 - 1;
					}
				}

				// If there is a change in occupied range, 
				// check if any other cars block the way
				// If so, clip the range to the blocked car
				if (new_min_i < min_i)
					for (var i = min_i - 1; i >= new_min_i; i--)
						if (occupied[i][d.j]) {
							new_min_i = i + 1;
							new_max_i = new_min_i + (d.length - 1);
							break;
						}
				if (new_max_i > max_i)
					for (var i = max_i + 1; i <= new_max_i && i <= 6 - 1; i++)
						if (occupied[i][d.j]) {
							new_max_i = i - 1;
							new_min_i = new_max_i - (d.length - 1);
							break;
						}

				// Calculate the final position x and update i value
				if (new_max_i - new_min_i == d.length - 1) {
					// If the main car escapes
					if (d.name == 'X' && new_max_i == 6) {
						onCarExit(car, d);
						return;
					}

					// If the car fits right to the grid, fit to grid
					d.i = new_min_i;
					x = i_to_x(new_min_i);
				} else if (new_max_i - new_min_i == d.length) {
					// If the car is in between two cells
					// No clipping should have happened
					if (x < i_to_x(new_min_i) || 
						x + d.length * cellSize > i_to_x(new_max_i + 1))
						throw new Error("Wrong implementation");
					if (clip) {
						new_min_i = Math.round((x - startX) / cellSize);
						new_max_i = new_min_i + d.length - 1;
						d.i = new_min_i;
						x = i_to_x(new_min_i);
					} else {
						d.i = Math.round((x - startX) / cellSize);
					}
				} else {
					throw new Error("New car range has wrong length - \
						There might be something wrong with implementation");
				}

				// update the occupied grid
				for (var i = min_i; i <= max_i; i++)
					occupied[i][d.j] = false;
				for (var i = new_min_i; i <= new_max_i; i++)
					occupied[i][d.j] = true;

				// Update the range
				d.min_i = new_min_i;
				d.max_i = new_max_i;

				// Update the x value
				car.attr("x", d.x = x);
			}

			/*
			 * Function that updates the car
			 * 'car': Vertical car HTML element
			 * d: Data attached to car
			 * y: New (suggested) position of the car
			 * cilp: true if the car has to be clipped, false if not
			 * 
			 * Updates the position, metadata
			 */
			function updateVerticalCar(car, d, y, clip) {
				// Calculate the new range of indicies the car will take
				var min_j = d.min_j, max_j = d.max_j;

				var new_min_j = Math.floor((y - startY) / cellSize);
				var new_max_j = Math.ceil((y - startY) / cellSize + d.length) - 1;					

				// If new range is out of screen, clip to screen.
				if (new_min_j < 0) {
					new_min_j = 0;
					new_max_j = d.length - 1;
				}
				if (new_max_j >= 6) {
					new_min_j = 6 - d.length;
					new_max_j = 6 - 1;
				}

				// If there is a change in occupied range, 
				// check if any other cars block the way
				// If so, clip the range to the blocked car
				if (new_min_j < min_j)
					for (var j = min_j - 1; j >= new_min_j; j--)
						if (occupied[d.i][j]) {
							new_min_j = j + 1;
							new_max_j = new_min_j + (d.length - 1);
							break;
						}
				if (new_max_j > max_j)
					for (var j = max_j + 1; j <= new_max_j; j++)
						if (occupied[d.i][j]) {
							new_max_j = j - 1;
							new_min_j = new_max_j - (d.length - 1);
							break;
						}

				// Calculate the final position y and update j value
				if (new_max_j - new_min_j == d.length - 1) {
					// If the car fits right to the grid, fit to grid
					d.j = new_min_j;
					y = j_to_y(new_min_j);
				} else if (new_max_j - new_min_j == d.length) {
					// If the car is in between two cells
					// No clipping should have happened
					if (y < j_to_y(new_min_j) || 
						y + d.length * cellSize > j_to_y(new_max_j + 1))
						throw new Error("Wrong implementation");
					if (clip) {
						new_min_j = Math.round((y - startY) / cellSize);
						new_max_j = new_min_j + d.length - 1;
						d.j = new_min_j;
						y = j_to_y(new_min_j);
					} else {
						d.j = Math.round((y - startY) / cellSize);
					}
				} else {
					throw new Error("New car range has wrong length - \
						There might be something wrong with implementation");
				}

				// update the occupied grid
				for (var j = min_j; j <= max_j; j++)
					occupied[d.i][j] = false;
				for (var j = new_min_j; j <= new_max_j; j++)
					occupied[d.i][j] = true;

				// Update the range
				d.min_j = new_min_j;
				d.max_j = new_max_j;

				// Update the y value
				car.attr("y", d.y = y);
			}

			function onDrag(d) {
				if (d.name == 'X' && d.escaped)
					return;

				if (d.type == CarType.HORIZONTAL) {
					updateHorizontalCar(d3.select(this), d, d3.event.x, false);
				} else if (d.type == CarType.VERTICAL) {
					updateVerticalCar(d3.select(this), d, d3.event.y, false);
				}
			}

			function onDragEnd(d) {
				if (d.name == 'X' && d.escaped)
					return;

				d3.select(this).classed("active", false);

				if (d.type == CarType.HORIZONTAL) {
					updateHorizontalCar(d3.select(this), d, d3.event.x, true);
				} else if (d.type == CarType.VERTICAL) {
					updateVerticalCar(d3.select(this), d, d3.event.y, true);
				}
			}

			function easeWithInitialSpeed(s) {
				return function (t) {
					return t * (s + (1.0 - s) * t);
				}
			}

			var currentLevel = 0;

			// When the main car exits the screen
			function onCarExit(car, d) {
				// Clean up the occupied array
				for (var i = d.min_i; i <= d.max_i; i++)
					occupied[i][d.j] = false;
				d.i = 50;

				d.escaped = true;
				// Show the escape animation
				car.transition()
					.ease(easeWithInitialSpeed(0.4))
					.duration(1000)
					.attr("x", i_to_x(50))
					.remove()
					.on("end", onGameFinish);
			}

			function onGameFinish() {
				// Clean up the board
				svg.selectAll("rect").remove();

				currentLevel++;
				if (currentLevel < rawLevelStrings.length)
					loadLevel(rawLevelStrings[currentLevel]);
				else 
					ending();
			}

			function ending() {
				function scene0() {
					svg.append("text")
						.attr("x", "170").attr("y", "200")
						.attr("font-family", "helvetica")
						.attr("font-size", "30")
						.text("Congratulations!");
					d3.transition().duration(2000).on("end", scene1);	
				}
				function scene1() {
					svg.append("text")
						.attr("x", "170").attr("y", "300")
						.attr("font-family", "helvetica")
						.attr("font-size", "30")
						.text("Let me give you a bronze medal.");
					d3.transition().duration(2000).on("end", scene2);
				}
				function scene2() {
					var medal = svg.append("image")
						.attr("href", "bronze.png")
						.attr("x", "270").attr("y", "300")
						.attr("opacity", "0");
					medal.transition().ease(d3.easeQuadOut).duration(3000)
						.attr("opacity", "1").transition().duration(1000).on("end", scene3);
				}
				function scene3() {
					svg.append("text")
						.attr("x", "170").attr("y", "650")
						.attr("font-family", "helvetica")
						.attr("font-size", "30")
						.text("To be continued...");
				}
				scene0();
			}

			loadLevel(rawLevelStrings[0]);
		</script>
	</body>
</html>